grammar co.edu.icesi.eketal.Eketal with org.eclipse.xtext.xbase.Xbase

import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes

generate eketal "http://www.icesi.edu.co/eketal/Eketal"

//////////////////////////////////////////////////////////////////////////
/////////////////////////////Event Class//////////////////////////////////
//////////////////////////////////////////////////////////////////////////

Model:
	('package' name = QualifiedName ->';'?)?
	importSection = XImportSection?
	typeDeclaration = EventClass?
;

EventClass:
	'eventclass' name=ID '{' declarations+=Decl* '}'
;
	
Decl:
	Automaton
	| Rc
	| MSig
	| JVarD
	| Group
	| EvDecl
;

JVarD:
	name=ValidID ':' type=JvmTypeReference//Variable en java
;

MSig:
	'op' name=ValidID '(' (params+=FullJvmFormalParameter (',' params+=FullJvmFormalParameter)*)? ')' (':' type=JvmTypeReference)? 
		body=XBlockExpression
;

//////////////////////////////////////
//Event Declaration
//////////////////////////////////////

EvDecl:
	'event' name=ID'(' (params+=FullJvmFormalParameter (',' params+=FullJvmFormalParameter)*)? ')'":"eventos+=OrEvent*';'
;

OrEvent returns EventExpression:
	AndEvent ({OrEvent.left=current} op='||' right=AndEvent)*
;

AndEvent returns EventExpression:
	NotEvent ({AndEvent.left=current} op='&&' right=NotEvent)*
;

NotEvent returns EventExpression:
	AtomEvent | UnaryExpresion
;

UnaryExpresion returns EventExpression:{UnaryEvent}
	op='!' expr=AtomEvent
	//{UnaryEvent} => op='!' expr=AtomEvent //TODO significado de =>
;

AtomEvent returns EventExpression:
	tipoEvento=EventPredicate | '('OrEvent')'
;

EventPredicate:
	KindAttribute
	| Trigger
;
	
KindAttribute:
	'host' '('hostgroup=[Group]')'
	| 'on' '('ongroup=[Group]')'
	| 'if' condition=XParenthesizedExpression
//	| 'eq'"("JExp","JExp")"
;

Trigger:
	'call' '(' returndef=TypeReturn esig=QualifiedName'('(params+=JvmTypeReference 
		(',' params+=JvmTypeReference)* )?')'')'
;

TypeReturn returns JVMTYPE:
	astk=ANY | jvmRef=JvmTypeReference
;

terminal ANY:
	'*'
;

Group:
	'group' name=ID
	'{' hosts+=Host* '}'
;
	
Host:
	ip=Ip
	| groupId=[Group]
;

Ip:
	"jphost" | "localhost" | Number':'Number
;

//////////////////////////////////////
////Automata definicion
//////////////////////////////////////
//TODO el estado inicial debe tener transiciones, porque sino, no se puede llegar a ningún lado
//TODO estado de finalización default
//TODO Restricción de que solo puede haber un autómata
Automaton:
	'automaton' name=ID '('(params+=FullJvmFormalParameter 
        (',' params+=FullJvmFormalParameter)*)?')' '{' steps+=Step* '}'
;
        
Step:
	(type=StateType)? name=ID ( ':' '('transitions+=TransDef')' ('||' '('transitions+=TransDef* ')')* )? ';'
;

TransDef:
	event=[EvDecl] '->' target=[Step]//XExpression//estado muerto
;

enum StateType:
	state |
	start |
	end
;

//////////////////////////////////////
////Reaction definition
//////////////////////////////////////
Rc:
	(syncex="syncex")? 'reaction' pos=Pos automaton=[Automaton]'.'state=[Step] body=Body
//	(syncex="syncex")? 'reaction' pos=Pos (state=[Step|QFN]) body=Body//This implementations works with the fully qualifiedname, so the program suggested all the name (package.eventclass.automaton.step) instead of only automaton.step
;

//QFN:
//    ID ('.' ID)*
//;

enum Pos:
	before | around | after
;

Body:
	body=XBlockExpression
//	body=XBlockExpression | 'addGroup' '('grupo=[Group]')' | 'removeGroup' '('grupo=[Group]')'
;

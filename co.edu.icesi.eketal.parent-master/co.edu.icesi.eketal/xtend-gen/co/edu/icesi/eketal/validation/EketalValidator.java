/**
 * generated by Xtext 2.9.2
 */
package co.edu.icesi.eketal.validation;

import co.edu.icesi.eketal.eketal.Automaton;
import co.edu.icesi.eketal.eketal.EketalPackage;
import co.edu.icesi.eketal.eketal.EvDecl;
import co.edu.icesi.eketal.eketal.EventClass;
import co.edu.icesi.eketal.eketal.Group;
import co.edu.icesi.eketal.eketal.Host;
import co.edu.icesi.eketal.eketal.Model;
import co.edu.icesi.eketal.eketal.StateType;
import co.edu.icesi.eketal.eketal.Step;
import co.edu.icesi.eketal.eketal.TransDef;
import co.edu.icesi.eketal.validation.AbstractEketalValidator;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class EketalValidator extends AbstractEketalValidator {
  public final static String INVALID_FILE_NAME = "eketal.issue.invalidFileName";
  
  public final static String NON_CAPITAL_NAME = "eketal.issue.nonCapitalName";
  
  public final static String DETERMINIST_AUTOMATON_DEFINITION = "eketal.issue.deterministAutomatonDefinition";
  
  public final static String NO_INITIAL_STATE_FOUND = "eketal.issue.noInitialStateFound";
  
  public final static String MANY_INITIAL_STATES_FOUND = "eketal.issue.manyInitialStatesFound";
  
  public final static String NO_TRANSITIONS_FROM_INITIAL_STATE = "eketal.issue.noTransitionsFromInitialState";
  
  public final static String NO_VALID_IP = "eketal.issue.noValidIpOnGroup";
  
  public final static String REPEATED_EVENT_NAME = "eketal.issue.repeatedEventName";
  
  public final static String REPEATED_AUTOMATON_NAME = "eketal.issue.repeatedAutomatonName";
  
  @Check
  public void checkRepeatedDeclarationsName(final EventClass myClass) {
    Iterable<EvDecl> events = Iterables.<EvDecl>filter(myClass.getDeclarations(), EvDecl.class);
    final Function1<EvDecl, String> _function = (EvDecl ev) -> {
      return ev.getName();
    };
    final Function2<String, List<EvDecl>, Boolean> _function_1 = (String e, List<EvDecl> l) -> {
      int _size = l.size();
      return Boolean.valueOf((_size > 1));
    };
    final Map<String, List<EvDecl>> duplicate = MapExtensions.<String, List<EvDecl>>filter(IterableExtensions.<String, EvDecl>groupBy(events, _function), _function_1);
    boolean _isEmpty = duplicate.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      Set<String> _keySet = duplicate.keySet();
      for (final String event : _keySet) {
        String _name = myClass.getName();
        String _plus = ((("The event \'" + event) + "\' is repeated in \'") + _name);
        String _plus_1 = (_plus + 
          "\'");
        this.error(_plus_1, EketalPackage.Literals.EVENT_CLASS__DECLARATIONS, EketalValidator.REPEATED_EVENT_NAME);
      }
    }
    Iterable<Automaton> automatons = Iterables.<Automaton>filter(myClass.getDeclarations(), Automaton.class);
    final Function1<Automaton, String> _function_2 = (Automaton aut) -> {
      return aut.getName();
    };
    final Function2<String, List<Automaton>, Boolean> _function_3 = (String e, List<Automaton> l) -> {
      int _size = l.size();
      return Boolean.valueOf((_size > 1));
    };
    final Map<String, List<Automaton>> duplicateAutomaton = MapExtensions.<String, List<Automaton>>filter(IterableExtensions.<String, Automaton>groupBy(automatons, _function_2), _function_3);
    boolean _isEmpty_1 = duplicateAutomaton.isEmpty();
    boolean _not_1 = (!_isEmpty_1);
    if (_not_1) {
      Set<String> _keySet_1 = duplicateAutomaton.keySet();
      for (final String automaton : _keySet_1) {
        String _name_1 = myClass.getName();
        String _plus_2 = ((("The automaton \'" + automaton) + "\' is repeated in \'") + _name_1);
        String _plus_3 = (_plus_2 + 
          "\'");
        this.error(_plus_3, EketalPackage.Literals.EVENT_CLASS__DECLARATIONS, EketalValidator.REPEATED_AUTOMATON_NAME);
      }
    }
  }
  
  @Check
  public void checkAutomatonDeterminism(final Step step) {
    final Function1<TransDef, EvDecl> _function = (TransDef t) -> {
      return t.getEvent();
    };
    final Function2<EvDecl, List<TransDef>, Boolean> _function_1 = (EvDecl e, List<TransDef> l) -> {
      int _size = l.size();
      return Boolean.valueOf((_size > 1));
    };
    final Map<EvDecl, List<TransDef>> duplicate = MapExtensions.<EvDecl, List<TransDef>>filter(IterableExtensions.<EvDecl, TransDef>groupBy(step.getTransitions(), _function), _function_1);
    boolean _isEmpty = duplicate.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      Set<EvDecl> _keySet = duplicate.keySet();
      for (final EvDecl event : _keySet) {
        String _name = step.getName();
        String _plus = ("The step \'" + _name);
        String _plus_1 = (_plus + "\' cannot have another transition with the same event as \'");
        String _name_1 = event.getName();
        String _plus_2 = (_plus_1 + _name_1);
        String _plus_3 = (_plus_2 + 
          "\'");
        this.error(_plus_3, EketalPackage.Literals.STEP__TRANSITIONS, EketalValidator.DETERMINIST_AUTOMATON_DEFINITION);
      }
    }
  }
  
  @Check
  public void checkAutomatonDeterminism(final Group group) {
    EList<Host> _hosts = group.getHosts();
    for (final Host host : _hosts) {
      try {
        boolean _not = (!(host.getIp().equals("localhost") || host.getIp().equals("jphost")));
        if (_not) {
          String[] bytes = host.getIp().split("\\.");
          for (final String byteIter : bytes) {
            boolean _equals = Objects.equal(byteIter, "*");
            if (_equals) {
            } else {
              if (((Integer.parseInt(byteIter) < 0) || (Integer.parseInt(byteIter) > 255))) {
                String _name = group.getName();
                String _plus = ((("The host \'" + host) + "\' cannot be resolved because their bytes must must be between 0<x<255 in \'") + _name);
                String _plus_1 = (_plus + 
                  "\'");
                this.error(_plus_1, EketalPackage.Literals.GROUP__NAME, EketalValidator.NO_VALID_IP);
              }
            }
          }
          String _ip = host.getIp();
          String _plus_2 = ("http://" + _ip);
          URL test = new URL(_plus_2);
        }
      } catch (final Throwable _t) {
        if (_t instanceof MalformedURLException) {
          final MalformedURLException exception = (MalformedURLException)_t;
          String _ip_1 = host.getIp();
          String _plus_3 = ("The host \'" + _ip_1);
          String _plus_4 = (_plus_3 + "\' cannot be resolved as a correct address in the group\'");
          String _name_1 = group.getName();
          String _plus_5 = (_plus_4 + _name_1);
          String _plus_6 = (_plus_5 + 
            "\'");
          this.error(_plus_6, EketalPackage.Literals.GROUP__NAME, EketalValidator.NO_VALID_IP);
        } else if (_t instanceof Exception) {
          final Exception e = (Exception)_t;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
    }
  }
  
  @Check
  public void checkInitialState(final Automaton automaton) {
    final Function1<Step, Boolean> _function = (Step s) -> {
      StateType _type = s.getType();
      return Boolean.valueOf(Objects.equal(_type, StateType.START));
    };
    final Iterable<Step> initialState = IterableExtensions.<Step>filter(automaton.getSteps(), _function);
    int _size = IterableExtensions.size(initialState);
    boolean _equals = (_size == 0);
    if (_equals) {
      String _name = automaton.getName();
      String _plus = ("The automaton \'" + _name);
      String _plus_1 = (_plus + "\' must have an initial State \'");
      String _plus_2 = (_plus_1 + 
        "\'");
      this.error(_plus_2, EketalPackage.Literals.AUTOMATON__STEPS, EketalValidator.NO_INITIAL_STATE_FOUND);
    } else {
      int _size_1 = IterableExtensions.size(initialState);
      boolean _greaterThan = (_size_1 > 1);
      if (_greaterThan) {
        for (final Step state : initialState) {
          String _name_1 = automaton.getName();
          String _plus_3 = ("The automaton \'" + _name_1);
          String _plus_4 = (_plus_3 + "\' can only have one initial state \'");
          String _plus_5 = (_plus_4 + 
            "\'");
          this.error(_plus_5, EketalPackage.Literals.AUTOMATON__STEPS, EketalValidator.MANY_INITIAL_STATES_FOUND);
        }
      } else {
        for (final Step state_1 : initialState) {
          if ((Objects.equal(state_1.getTransitions(), null) || state_1.getTransitions().isEmpty())) {
            String _name_2 = automaton.getName();
            String _plus_6 = ("The automaton \'" + _name_2);
            String _plus_7 = (_plus_6 + "\' must have at least one transition in his initial state \'");
            String _name_3 = state_1.getName();
            String _plus_8 = (_plus_7 + _name_3);
            String _plus_9 = (_plus_8 + 
              "\'");
            this.error(_plus_9, EketalPackage.Literals.AUTOMATON__STEPS, EketalValidator.NO_TRANSITIONS_FROM_INITIAL_STATE);
          }
        }
      }
    }
  }
  
  public String fromURItoFQN(final URI resourceURI) {
    ArrayList<String> segments = new ArrayList<String>();
    int _size = ((List<String>)Conversions.doWrapArray(resourceURI.segments())).size();
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      List<String> _segmentsList = resourceURI.segmentsList();
      int _size_1 = ((List<String>)Conversions.doWrapArray(resourceURI.segments())).size();
      int _minus = (_size_1 - 1);
      segments.addAll(_segmentsList.subList(3, _minus));
      segments.add(resourceURI.lastSegment().substring(0, resourceURI.lastSegment().lastIndexOf(".")));
    } else {
      boolean _contains = resourceURI.lastSegment().contains(".");
      if (_contains) {
        segments.add(resourceURI.lastSegment().substring(0, resourceURI.lastSegment().lastIndexOf(".")));
      } else {
        segments.add(resourceURI.lastSegment());
      }
    }
    final Function2<String, String, String> _function = (String r, String t) -> {
      String _xifexpression = null;
      boolean _isEmpty = r.isEmpty();
      if (_isEmpty) {
        _xifexpression = t;
      } else {
        _xifexpression = ((r + ".") + t);
      }
      return _xifexpression;
    };
    return IterableExtensions.<String, String>fold(segments, "", _function);
  }
  
  @Check
  public void checkMonitorStartsWithCapital(final EventClass typeDecl) {
    boolean _isUpperCase = Character.isUpperCase(typeDecl.getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Name should start with a capital", EketalPackage.Literals.EVENT_CLASS__NAME, 
        EketalValidator.NON_CAPITAL_NAME);
    }
  }
  
  @Check
  public void checkTypeDeclarationNameMatchesPhysicalName(final EventClass typeDecl) {
    final URI URI = typeDecl.eResource().getURI();
    String _lastSegment = URI.lastSegment();
    int _indexOf = URI.lastSegment().indexOf(URI.fileExtension());
    int _minus = (_indexOf - 1);
    final String fileName = _lastSegment.substring(0, _minus);
    final boolean isPublic = ((!Objects.equal(typeDecl.eContainer(), null)) && (typeDecl.eContainer() instanceof Model));
    if ((isPublic && (!fileName.equals(typeDecl.getName())))) {
      String _name = typeDecl.getName();
      String _plus = ("The declared type \'" + _name);
      String _plus_1 = (_plus + "\' does not match the corresponding file name \'");
      String _plus_2 = (_plus_1 + fileName);
      String _plus_3 = (_plus_2 + 
        "\'");
      this.error(_plus_3, EketalPackage.Literals.EVENT_CLASS__NAME, EketalValidator.INVALID_FILE_NAME);
    }
  }
}
